# Balancing Policy

## Introduction

The Balancing Policy provides a new load balancing mode that complements Kubernetes services, achieving global layer 4 load balancing across the cluster.

It supports request redirection for the following objects:
* Applications within Pods
* Applications on cluster nodes
* Applications on external hosts

## Features

Current features include:
* [x] Customizable front address for load balancing, which can be a Kubernetes service name or a custom VIP and port.
* [x] Customizable backend address for load balancing, specified by pod label selector, supporting the following three methods:
    * **endpoint IP**: The load balancing address is DNAT resolved to the pod IP, applicable to all PODs.
    * **HostPort**: The load balancing address is DNAT resolved to the node IP where the pod resides and the pod's HostPort, applicable to PODs with defined hostPort.
    * **nodeProxy**: The load balancing address is DNAT resolved to the node's Proxy IP and the port defined in the policy, applicable to all PODs. The node's Proxy IP is defined in the node object's annotation `"balancing.elf.io/nodeProxyIpv4": "192.168.0.10"`, which can be generated by:
        * The Balancing agent automatically establishing a tunnel interface on the node and updating it to the node's annotation, suitable for multi-cluster or external host applications.
        * Administrators manually setting the annotation `"balancing.elf.io/nodeProxyIpv4"` on the Node object, such as proxy mapping IP or public mapping IP.

> Note: The front of Balancing Policy and LocalRedirect Policy instances does not support binding the same service or defining the same virtual address, as this will cause resolution conflicts.

> If the front of Balancing Policy or LocalRedirect Policy uses a custom IP address that conflicts with a Kubernetes service ClusterIP, it will be resolved according to the rules of Balancing Policy or LocalRedirect Policy.

Future versions will address the following issues:
* [ ] Balancing Agent will support automatically establishing forwarding tunnels between nodes and updating IP addresses to the node's annotation `"balancing.elf.io/nodeProxyIpv4"`, to achieve communication with external hosts and multi-cluster in overlay CNI scenarios.

## Use Cases

1. Running the balancing agent binary or docker service on external hosts, kubevirt virtual machines, or kubedge edge nodes to access services within the Kubernetes cluster.

   Traditional nodePort or Loadbalancer load balancing may encounter SNAT source port conflicts, long connection timeouts, and other issues, becoming bottlenecks for high concurrency access. The new balancing solution enables client-side load balancing resolution, reducing forwarding paths and lowering troubleshooting difficulty.

    > In the current version, Balancing has not yet completed tunnel establishment and port allocation between nodes, so it can only ensure connectivity within and outside the cluster in underlay CNI scenarios. In future versions, once Balancing completes tunnel establishment, it will ensure connectivity within and outside the cluster in overlay CNI scenarios.

2. Achieving layer 4 load balancing access between multiple clusters.

   > In the current version, Balancing has not yet completed tunnel establishment and port allocation between nodes, so it can only ensure connectivity within and outside the cluster in underlay CNI scenarios. In future versions, once Balancing completes tunnel establishment, it will ensure connectivity within and outside the cluster in overlay CNI scenarios.

3. Customizing front load balancing addresses or backend forwarding addresses to support more flexible load balancing needs.

## Policy Examples

In the following example, the front specifies a service in Kubernetes, and the backend forwards to the Pod IP based on the pod's label selector.

```shell
apiVersion: balancing.elf.io/v1beta1
kind: BalancingPolicy
metadata:
  name: test-service-podendpoint
spec:
  enabled: true
  frontend:
    serviceMatcher:
      serviceName: http-server-balancing-pod-v4
      namespace: default
      toPorts:
        - port: "8080"
          protocol: TCP
          name: p1
        - port: "80"
          protocol: TCP
          name: p2
  backend:
    serviceEndpoint:
      endpointSelector:
        matchLabels:
          app: http-redirect
      redirectMode: podEndpoint
      toPorts:
        - port: "80"
          protocol: TCP
          name: p1
        - port: "80"
          protocol: TCP
          name: p2
```

In the following example, the front specifies a service in Kubernetes, and the backend forwards to the HostPort of the node where the Pod resides based on the pod's label selector.

```shell
apiVersion: balancing.elf.io/v1beta1
kind: BalancingPolicy
metadata:
  name: test-service-hostport
spec:
  enabled: true
  frontend:
    serviceMatcher:
      serviceName: http-server-balancing-hostport-v4
      namespace: default
      toPorts:
        - port: "80"
          protocol: TCP
          name: p2
  backend:
    serviceEndpoint:
      endpointSelector:
        matchLabels:
          app: http-redirect
      redirectMode: hostPort
      toPorts:
        - port: "20080"
          protocol: TCP
          name: p2
EOF
```

In the following example, the front specifies a service in Kubernetes, and the backend forwards to the Proxy IP of the node where the Pod resides based on the pod's label selector.

```shell
apiVersion: balancing.elf.io/v1beta1
kind: BalancingPolicy
metadata:
  name: test-service-nodeproxy
spec:
  enabled: true
  frontend:
    serviceMatcher:
      serviceName: http-server-balancing-nodeproxy-v4
      namespace: default
      toPorts:
        - port: "80"
          protocol: TCP
          name: p2
  backend:
    serviceEndpoint:
      endpointSelector:
        matchLabels:
          app: http-redirect
      redirectMode: nodeProxy
      toPorts:
        - port: "20080"
          protocol: TCP
          name: p2
EOF
```

In the following example, the front uses a custom virtual IP and port, and the backend uses a custom IP and port.

```shell
apiVersion: balancing.elf.io/v1beta1
kind: BalancingPolicy
metadata:
  name: test-addr
spec:
  enabled: true
  frontend:
    addressMatcher:
      ip: "169.254.169.254"
      toPorts:
        - port: "8080"
          protocol: TCP
          name: p1
        - port: "80"
          protocol: TCP
          name: p2
  backend:
    addressEndpoint:
      addresses:
        - "1.1.1.1"
        - "1.1.1.2"
      toPorts:
        - port: "80"
          protocol: TCP
          name: p1
        - port: "80"
          protocol: TCP
          name: p2
```
